---
description: Поэтапный план реализации
---

0) Цели MVP и границы ответственности
Цели

Онлайн-остатки по складам/ячейкам: сколько доступно, сколько в резерве, в ремонте, в пути, на магазине, не установлено.

Заявки от техподдержки: создание, резервы, сборка, доставка, установка.

Доставка по API (Яндекс.Доставка): создание заказа, получение статусов/событий, отображение таймлайна.

Карточка магазина: установленное оборудование + статусы + “что отправлено/в пути/доставлено, но не установлено”.

Шаблоны заявок (создают кладовщик/начальники).

Комментарий-стенка под заявкой/отгрузкой (мини-чат).

Реальное время: обновления статусов, остатков, доставок.

Безопасность: защита пользователей, сессий, API, БД, инфраструктуры.

1) Технологический стек (рекомендованный, масштабируемый)
Frontend

Next.js (App Router)

Tailwind CSS

shadcn/ui (ты это и описал как “ChatC UI” — по сути оно)

Таблицы: TanStack Table (для фильтров/сортировок/вьюх)

Реальное время: WebSocket / SSE клиент

Backend (вариант, который хорошо масштабируется)

NestJS (Node.js) — для модульности, авторизации, очередей и интеграций

REST API + WebSocket Gateway

Валидация: class-validator / zod (на границе API)

Хранилища и инфраструктура

PostgreSQL (основная БД)

Redis (кэш + rate limit + хранение короткоживущих токенов Telegram-логина + очереди/locks)

Очередь задач: BullMQ (Redis) для:

polling статусов доставок

обработка вебхуков

прогнозирование/аналитика

Объектное хранилище для фото: S3-совместимое (MinIO/Cloudflare R2)

Observability:

структурированные логи (pino)

метрики (Prometheus) + графики (Grafana)

трассировка (опционально)

Если у тебя уже выбран “вот такой backend” (например FastAPI) — логика плана не меняется: модули/сущности/безопасность одинаковые. Меняется только реализация.

2) Роли и права (RBAC)
Роли

Кладовщик

складские операции (приход/списание/перемещение)

сборка отгрузок

статусы оборудования (ремонт/тест/дефект/списание)

создание шаблонов (опционально) или только использование

Техподдержка

создание заявок

просмотр доступности

инициирование доставки (создание заказа доставки)

комментарии/обсуждения

фиксация “установлено/не установлено” (если разрешишь) или только запрос статуса у магазина

Начальник (почти админ)

почти всё: справочники, шаблоны, отчёты, корректировки

ограничения (по желанию): управление интеграциями/секретами только у Admin

Админ

пользователи, роли, настройки, интеграции, ключи, политики безопасности

Матрица прав (минимум)

CRUD справочников (оборудование, склады, магазины, статусы)

операции склада (только кладовщик/начальник)

создание заявок (support/начальник)

подтверждение отгрузки (кладовщик/начальник)

управление интеграциями (админ)

3) Доменные сущности (что хранит система)
Номенклатура

Product (модель/тип оборудования)

Asset (серийное оборудование: SN, состояние, локация)

StockItem (расходники: количественный учёт)

Локации

Warehouse (склад)

WarehouseBin (ячейка/стеллаж/зона)

Store (магазин)

Процессы

Request/Ticket (заявка)

Shipment (отгрузка)

ShipmentItem

asset_id (серийник) или stock_item_id + qty

Доставка (интеграции)

DeliveryOrder

provider (YANDEX_DELIVERY / MAJOR / …)

external_id (claim_id)

tracking_number (если есть)

status (нормализованный)

raw_payload (JSON)

DeliveryEvent (история событий)

Комментарии

Thread (привязка к заявке/отгрузке)

Comment (сообщения, ответы, упоминания)

Аудит и безопасность

AuditLog (кто/что/когда изменил)

AuthSession / RefreshTokens (если делаешь refresh)

TelegramLoginAttempt (одноразовые попытки)

4) Статусы (расширенные, как ты хотел)
Для Asset (серийное)

Раздели на 3 измерения:

(A) Локация

MAIN_WAREHOUSE / BIN

IN_TRANSIT

STORE

SERVICE_CENTER

LOST / UNKNOWN

(B) Тех. состояние

WORKING

DEFECTIVE

ON_TESTING

REQUIRES_REPAIR

WAITING_PARTS

NOT_REPAIRABLE

REQUIRES_WRITE_OFF

(C) Процесс

FREE

RESERVED

PICKED

WAITING_SHIPMENT

IN_SHIPMENT

DELIVERED

NOT_INSTALLED ✅ (ключевой)

INSTALLED ✅ (ключевой)

WAITING_REPAIR_SHIPMENT

IN_REPAIR

WRITE_OFF_IN_PROGRESS

WRITTEN_OFF

Для StockItem (расходники)

qty_on_hand

qty_reserved

qty_available = on_hand − reserved

минимальный остаток + прогноз

5) Реальное время (live-обновления)
Какие события должны “пушиться” в UI

изменение остатков (stock/asset)

изменение статуса заявки

изменение статуса отгрузки

новые события доставки (delivery events)

новые комментарии

алерты SLA/просрочки

Технически

WebSocket канал с авторизацией (JWT/cookie)

или SSE (проще, если только “сервер → клиент”)

6) Авторизация
6.1 Email + пароль

Email + password

Пароли: Argon2id (или bcrypt, но argon2 лучше)

MFA (опционально, но я рекомендую хотя бы для начальников/админов)

6.2 Telegram approve-login (как ты описал)
UX-сценарий

На сайте пользователь выбирает “Войти через Telegram”

Вводит Telegram username или Telegram ID (лучше ID, но UX хуже; можно дать оба)

Нажимает “Запросить вход”

Бэкенд создаёт login_attempt:

attempt_id

user_id

code (одноразовый)

TTL 60–120 секунд

статус: PENDING

Бэкенд отправляет в Telegram-бота пользователю сообщение:

“Запрос входа в панель”

Данные: IP/город (если хочешь), браузер, время

Кнопки: ✅ Принять / ❌ Отклонить

Пользователь нажимает:

Принять → бот дергает backend POST /auth/telegram/approve с подписью бота

Backend выставляет attempt APPROVED и выдаёт сессию/JWT (см. ниже)

Сайт опрашивает attempt:

либо polling GET /auth/telegram/attempt/{id}

либо WS event “approved”

После APPROVED сайт получает токены и логинит пользователя.

Важные детали безопасности

Никаких логинов по username без привязки.

Username может меняться.

Должна быть привязка: user.telegram_id фиксированный.

Первый раз привязка Telegram-ID к пользователю делается:

либо админом,

либо через “link flow” (пользователь пишет /start боту → получает код → вводит в панель).

Все approve/deny запросы от бота подписываются секретом (например HMAC) или делаются через внутреннюю сеть/allowlist.

TTL на попытку логина короткий.

Лимиты на количество попыток.

Как выдавать сессию

Рекомендация:

HttpOnly secure cookies (access + refresh) или только session cookie.

Access токен короткий (10–15 мин), refresh дольше (7–30 дней).

При approve: либо сразу выдавать cookies в браузер через “finish endpoint”, либо отдавать “one-time exchange token” и обменивать на cookies.

7) Интеграция Яндекс.Доставка (легковая/грузовая)
7.1 Модуль “Delivery”

Функции:

создать доставку из Shipment

получить/синхронизировать статус по external_id

писать DeliveryEvent

нормализовать статусы в твой формат:

CREATED / COURIER_ASSIGNED / PICKED_UP / IN_TRANSIT / DELIVERED / CANCELLED / PROBLEM

7.2 Способы обновления статусов

Polling активных доставок (каждые 1–5 минут)

Webhooks, если будут доступны — подключаем как улучшение

7.3 Таймлайн доставки (обязательная фича)

В UI показывается:

события от Яндекса

внутренние события (сборка, передано курьеру)

итог: доставлено → перевод оборудования в DELIVERED, и ожидание INSTALLED

8) “Доставлено” ≠ “Установлено” (твоя ключевая логика)

После DELIVERED:

Asset получает DELIVERED + NOT_INSTALLED

На дашборде появляется виджет:

“Доставлено, но не установлено: 12 устройств”

Дальше фиксация INSTALLED:

либо вручную support/магазин (через роль/ограничение)

либо через отдельный чек-лист “монтаж подтверждён”

9) Карты и маршрут в карточке магазина/создании доставки
Что делать

В карточке магазина и на шаге “Выбор склада отправки”:

отображать карту

строить маршрут склад → магазин

показывать ETA + “надбавку” на поиск курьера (конфигом, например +10–20 минут)

Реализация:

либо через Яндекс.Карты API (если есть ключ/договор),

либо через альтернативный routing provider (если Яндекс.Карты недоступны на сервере)

10) Прогнозирование пополнений (ускоряет и даёт “умность”)
MVP-версия прогнозирования (без ML-магии)

считаем средний расход по SKU за 7/14/30 дней

учитываем lead time поставки

прогнозируем дату “stockout”

предлагаем “рекомендованный уровень” (min/max)

Вывод в панели:

“Пополнить Router X: сейчас 8 шт, прогноз 0 через 12 дней, рекомендуем +20”

11) UI/страницы (минимум для полной панели)
Общие

Dashboard (KPI + алерты)

Поиск (SN/магазин/заявка/доставка)

Уведомления (пока только просмотр, правила позже)

Склад

Каталог моделей (Product)

Серийники (Assets)

Расходники (StockItems)

Операции склада (приход/перемещение/списание/инвентаризация)

Процессы

Заявки (Requests)

Отгрузки (Shipments)

Доставки (Delivery Orders + timeline)

Магазины

Список магазинов

Карточка магазина (оборудование + статусы + отправки + карта)

Админка

Пользователи/Роли

Шаблоны заявок

Настройки интеграций (ключи, включение провайдеров)

Политики безопасности (IP allowlist, MFA, лимиты)

12) Безопасность (пунктами, “чтобы не взломали”)
12.1 На уровне приложения

RBAC + проверка прав на каждом endpoint

Защита от brute force:

rate limit на /auth/*

блокировки по IP/аккаунту

Пароли: Argon2id + политика сложности

Сессии:

HttpOnly Secure SameSite cookies

rotation refresh token

logout = отзыв refresh

CSRF защита (если cookies) — double submit или встроенные механизмы

Валидация входных данных везде

Audit log всех критичных действий (склад/права/интеграции)

12.2 На уровне API интеграций

Секреты в env/secret manager (не в коде)

Ограничение доступа к webhook endpoint:

подпись, allowlist, secret token

Логи без утечки персональных данных/секретов

12.3 База данных

БД не торчит в интернет (только private network)

отдельный пользователь БД с минимальными правами

регулярные бэкапы + шифрование бэкапов

миграции контролируемо (Prisma/TypeORM migrations)

12.4 Инфраструктура

Reverse proxy (Caddy/Nginx) + TLS

WAF/Cloudflare (если сайт наружу)

Firewall: открыты только 80/443

Обновления OS, fail2ban, SSH ключи, запрет password login

Изоляция контейнеров (Docker Compose/Swarm/K8s — позже)

12.5 Организационные меры (важно)

разные роли, запрет “все админы”

журнал действий начальников тоже

обязательная привязка Telegram-ID (а не username)

13) Поэтапная реализация (roadmap)
Этап 1 — База домена (склад)

Products, Assets, StockItems

Локации: склады/ячейки/магазины

Операции склада + audit log

UI таблицы + фильтры + поиск SN

Результат: уже можно вести склад и видеть доступность.

Этап 2 — Заявки + отгрузки

Requests (создание/статусы)

Резервы: серийники + qty расходников

Shipments: сборка, чек-лист, подтверждение

Комментарии под заявкой/отгрузкой (мини-чат)

Результат: процесс “заявка → сборка” работает.

Этап 3 — Яндекс.Доставка по API + таймлайн (обязательное)

DeliveryOrder + DeliveryEvent

Создание доставки из Shipment

Polling статусов

UI таймлайна

Автопереход DELIVERED → NOT_INSTALLED

Результат: реальное время по доставкам и прозрачность.

Этап 4 — Магазины “как центр правды”

Карточка магазина: оборудование + статусы + отправки

Список “доставлено, но не установлено”

Карта/маршрут + ETA (первичная версия)

Результат: руководители видят картину по точкам.

Этап 5 — Шаблоны + прогнозирование + алерты

Шаблоны заявок (создание склад/начальник)

Прогноз пополнений (простая модель)

SLA алерты (доставка/установка)

Первичная система уведомлений (пока без сложной матрицы получателей)

Результат: скорость, управление, меньше ручного контроля.

14) Что считать “идеалом MVP”

Минимально-идеальный комплект (по твоим приоритетам):

Автовыбор тарифа доставки (легк/груз) ✅

Таймлайн доставки ✅

“Новый магазин” как отдельная сборка/процесс ✅

Фотофиксация (опционально) ✅

Карточка магазина с оборудованием/статусами/отправками ✅

Шаблоны заявок (склад/начальник) ✅

Комментарии-стенка ✅

После Delivered → Not installed → Installed ✅

Маршрут на карте + ETA ✅

Прогноз пополнений ✅